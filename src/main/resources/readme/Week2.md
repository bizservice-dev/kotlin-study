# 3. 재귀, 공재귀, 메모화

## 3.1 재귀와 공재귀
### 공재귀
- 한 단계의 출력을 다음 단계의 입력으로 사용하는 계산 단계를 합성한 것으로, 첫 단계부터 계산을 시작한다.
- 각 단계를 즉시 계산할 수 있다.
- 계산 과정에 필요한 메모리 크기는 상수이다.


### 재귀
- 공재귀와 같은 연산을 수행하지만 마지막 단계부터 계산을 시작한다.
- 모든 단계를 어떤 형태로든 저장해야한다. 최종 조건을 찾은 다음에야 저장해둔 이전 단계를 역순으로 평가할 수 있다. 따라서 계산 과정에 필요한 메모리 크기는 단계의 수에 따라 증가한다.
- JVM에서는 중간단계를 저장하는 메모리가 작기 때문에 메모리 이슈가 발생할 수 있다. 코틀린은 약 20,000 단계를 스택에 넣을 수 있고, 자바는 3,000단계를 넣을 수 있다.
- 따라서 처리 단계가 작다는 것을 확신할 수 없다면 재귀함수를 공재귀로 전환하여 사용해야 한다.


## 3.2 꼬리 호출 제거(TCE)
- 공재귀 역시 스택 공간을 사용하기 때문에 아주 느리기는 하지만 스택을 고갈 시키는데, 공재귀 함수를 루프로 바꿈으로써 해결할 수 있다.
- 코틀린은 자동으로 공재귀를 루프로 변환해준다.
- 자바와 달리 코틀린은 꼬리 호출 제거(TCE, Tail Call Elimination)를 구현한다. 함수가 재귀 호출의 결과를 다른 연산에 사용하지 않고 즉시 반환한다면 코틀린은 이 꼬리 호출을 제거한다.
- 단, 이는 자동으로 수행되지 않으며 꼬리 호출 제거가 필요할 시 tailrec 키워드를 함수 선언 앞에 붙여서 컴파일러에 알려줘야 한다.  
```kotlin
// 주 함수
fun toString(list: List<Char>): String { 
    // 도우미 함수
    tailrec fun toString(list: List<Char>, s: String): String = 
        if (list.isEmpty())
            s
        else 
            toString(list.subList(1, list.size), append(s, list[0]))
 
    return toString(list, "")
}
```

- tailrec을 붙이면 아래와 같이 꼬리호출 구문이 루프문으로 변환되어 컴파일 된다.
```kotlin

// kotlin code
tailrec fun add(a: Int, b: Int): Int {
    return if (b == 0) {
        a
    } else {
        add(inc(a), dec(b))
    }
}
 
// java decompile code
public final int add(int a, int b) {
    while(b != 0) {
        int var10000 = this.inc(a);
        b = this.dec(b);
        a = var10000;
    }
    return a;
}
```

- tailrec 키워드를 사용하면 코틀린은 실제로 꼬리 재귀 함수가 맞는지 검사해서 알려준다. TCE를 적용할 수 없으면 다음과 같은 경고를 표시한다.
    > Warning: (16, 5) Kotlin: A function is marked as tail-recursive but no tail calls are found
  - 위 경고는 컴파일을 중단시키진 않지만 생성된 코드가 스택을 소진할 수 있으니 주의깊게 살펴봐야 한다.
- 재귀 함수 구현을 꼬리 재귀 구현으로 바꾸면 경우에 따라서 더 안전한 프로그램을 작성할 수 있다.
- 재귀 함수 값의 경우에 재귀가 꼬리 재귀라 하더라도 컴파일러가 TCE를 통한 최적화를 해주지 않는다. 꼬리 재귀를 사용하는 함수 값이 필요하면 함수 참조를 사용해야 한다.


#### 도우미 함수
- 도우미 함수를 주 함수 내부에 선언하면 이름 충돌을 피하고 주 함수의 파라미터 중 일부를 클로저를 사용해 공유할 수 있다.
- 도우미 함수 관례
    - 함수 내부에 로컬 함수를 정의할 수 있는 언어에서 현재 사용하는 관례의 하나눈 내부 도우미 함수를 `go`나 `process` 같은 이름으로 통일하는 것이다.
    - `sum_` 처럼 주 함수 이름 뒤에 밑줄(`_`)을 붙여 도우미 함수를 부르는 방식이 있다.
    - 주함수와 도우미 함수의 시그니처가 다르면 주 함수와 도우미 함수에 똑같은 이름을 붙일 수 있다.
    - 어떤 방식을 택하든 항상 일관성을 지키면 된다.


#### 이중 재귀 함수
- 이중 재귀 함수는 각 단계마다 자신을 두 번 호출하는 재귀함수이다. (ex, 피보나치 수열). 이 경우 2n  번의 재귀 호출이 발생하므로 사용을 피해야 한다. (n: 단계)
- 누적기(accumulator)를 사용하면 이를 꼬리재귀함수로 구현할 수 있다.


## 3.3 메모화
- 메모화(memoization)는 계산 결과를 메모리에 저장해 나중에 같은 계산을 다시 수행하지 않고 결과를 바로 반환하는 기법이다.
- 이를 사용하면 같은 인자로 두 번 이상 호출할 때 결과를 더 빨리 얻을 수 있다.
- 특정 값에 대해서 시간이 오래걸리거나 재귀호출이 많이 발생하여 StackOverFlow가 발생할 수 있는 경우 메모화를 통해서 최적화를 할 수 있을것으로 예상된다
- 메모화한 함수는 인자가 같으면 항상 같은 결과를 내놓으므로 원래 함수가 순수 함수라면 메모화한 함수도 여전히 순수함수다.
- 메모화를 사용할 때 두 가지 문제가 있는데, 이는 다음과 같이 해결할 수 있다.
  - 메모화를 사용하고 싶은 모든 함수를 메모화 방식으로 변경해야 한다. → 추상화 클래스(Memoizer)를 구현하여 사용한다.
  - 사용 중이 맵이 외부에 노출된다. → 함수를 따로 객체에 넣고 그 객체에 맵을 포함시키되 외부 접근을 막고 비공개로 맵을 넣는다.
- 메모화 시 잠재적 메모리 문제를 해결하기 위해서는 메모화한 값 저장 시 소프트 참조나 약한 참조를 사용해야 한다.
- 메모화의 예시는 다음과 같다.
```kotlin
// 일반 함수에 메모화 사용하기
class Memorizer<T, U> private constructor() {
 
    private val cache = ConcurrentHashMap<T, U>()
 
    private fun doMemoize(function: (T) -> U): (T) -> U = { x ->
        cache.computeIfAbsent(x) {
            function(it)
        }
    }
 
    companion object {
     
        fun <T, U> memoize(function: (T) -> U): (T) -> U = Memorizer<T, U>().doMemoize(function)
         
    }
}
 
val f: (Int) -> Int = { it * 2 }
val g: (Int) -> Int = Memoizer.memoize(f)
```