# 5. 리스트로 데이터 처리하기

## 리스트
- 리스트는 선형 컬렉션의 한 유형으로 가장 널리 쓰이는 데이터 구조다.
 
#### 컬렉션 (Collection)
- 서로 관계가 있는 데이터 원소들을 모아둔 그룹

##### 분류
  - 선형 컬렉션
    - 원소들이 일차원으로 관계된 컬렉션
    - 각 원소가 다음 원소와 연관되어 있다.
    - 예 : `List`
  - 연관 컬렉션
    - 함수처럼 생각할 수 있는 컬렉션
    - 연관 컬렉션에 속한 원소 사이에는 아무런 연관이 없다.
    - 예 : `Set` `Map`
  - 그래프 컬렉션
    - 각 원소가 여러 다른 원소와 연관되어 있는 컬렉션
    - 예 : `Tree` `Binary Tree`
##### 유형
  - 접근 유형
    - 어떤 리스트는 한쪽 끝에서만 접근할 수 있지만, 다른 리스트는 양 끝에서 모두 접근이 가능하다.
    - 어떤 리스트는 한쪽 끝에만 원소를 추가할 수 있지만, 다른 리스트는 반대쪽 끝에도 원소를 추가할 수 있다.
    - 리스트 중 일부는 원소의 위치를 알면 그 원소를 바로 읽을 수 있다. 이때 원소의 위치를 [[인덱스(Index)]]라고 한다.
  - 접근 순서
    - 어떤 리스트는 원소를 넣은 순서대로 원소를 읽을 수 있다. ([[선입선출(FIFO, First In First Out)]])
    - 원소를 넣은 순서와 원소를 꺼내는 순서가 반대인 리스트도 있다. ([[후입선출(LIFO, Last In First Out)]])
    - 일부 리스트는 완전히 다른 순서로 원소를 꺼내게 허용할 수도 있다.
  - 구현
    - 접근 유형과 접근 순서는 선택한 리스트 구현 방식과 밀접히 연관된다.
      - 리스트의 각 원소를 자신의 다음 원소와 연결하는 방식으로 구현한 리스트와 인덱스로 접근이 가능한 배열을 사용해 구현한 리스트는 접근 유형이라는 관점에서 동작이 완전히 다르다.
      - 각 원소와 그 원소의 다음 원소, 그 원소의 이전 원소를 연결하기로 결정한다면 양 끝에서 접근이 가능한 리스트를 만들 수 있다.
    - 여러 유형의 리스트는 원소에 대해 서로 다른 접근 방식을 제공한다.
      - 인덱스를 사용한 리스트 : 원하는 원소에 마음대로 접근할 수 있다.
      - 단일 연결 리스트 : 리스트 맨 앞에 있는 원소에만 접근할 수 있다.
      - 이중 연결 리스트 : 양 끝에 있는 원소에 접근할 수 있다.

##### 상대적인 예상 성능
 - 가장 자주 써야 하는 연산에서 `O(1)`을 추구하는 경우가 많고, 그리 자주 일어나지 않는 연산에 대해서는 `O(log(n))`을 받아 들일 수 있을 것이다. 심지어 그런 연산에 대해 `O(n)`을 감수할 수도 있다. (이런 식으로 데이터 구조의 성능을 측정하는 방식은 데이터 구조의 규모를 무한대로 키웠을 경우에 해당함.)
 - 크기 제약이 있으면 `O(n)` 접근 시간의 데이터 구조가 `O(1)` 접근 시간의 다른 데이터 구조보다 더 빠르게 동작할 수도 있다. (원소에 대한 접근 시간이 1 ns인 `O(n)` 성능의 데이터 구조가 원소에 대한 접근 시간이 1 ms인 `O(1)` 성능의 데이터구조보다 더 나은 경우도 자주 있다.)

## 제자리 갱신
- 데이터 구조의 상태를 변이해 데이터 구조를 이루는 원소들을 바꾸는 방식
- 단일 스레드 방식에서 좋은 방법이라고 여겨졌지만 실제로는 그렇지 않고, 다중 스레드 방식에서 돌아가고 있는 현재 프로그램에서 해당 방식은 여러가지 문제를 발생시킬 수 있다
- 문제점
    - 데이터 구조를 변이하게 허용한 경우에 이 데이터 구조를 아주 복잡한 보호 장치 없이 여러 스레드 사이에 공유할 수 없다. 그리고 이런 보호 장치는 단 한 번에 제대로 코딩하기 어렵다.
    - 이에 따라 교착 상태, 라이브락, 스레드 기아 상태, 낡은 데이터(stale data) 등 갖가지 문제가 발생한다.
- 제자리 갱신은 여러가지 문제를 가지고 있기 때문에 불변 데이터 구조를 사용해야 한다.
- 내용을 변경할 때는 새로운 상태를 표현하는 데이터를 만든다.
- 데이터를 공유하는 특별한 데이터 구조를 구현하는 방식으로도 해결할 수 있다.

## 데이터 공유 (Data Sharing)
- 데이터 공유는 불변이면서 영속적인 데이터 구조의 토대가 되는 기법
- 복사본을 만드는 대신에 기존의 데이터를 재사용한다.
- 기존의 데이터에서 추가 작업을 통해 새로운 값을 만들 때, 새로운 변수 또는 상수를 저장하는 것이 아닌, 수정된 부분 일부와 기존의 데이터를 활용하여 변수 또는 상수의 값을 저장하기 때문에 메모리 오버헤드가 크지 않다.
- 예시
```kotlin
sealed class List<A> {
    fun cons(elem: A): List<A> = List.Cons(elem, this)
}
```

## Sealed Class
- 추상클래스의 일종으로 상속받는 자식 클래스를 제한한다. 
- 컴파일러에서 자식 클래스를 모두 알고 있으며, `when` 같은 구문에서 모든 자식 클래스에 대해 처리해주지 않으면 컴파일 에러가 나는 등 모든 자식 클래스에 대해 안전하게 처리할 수 있게 해준다.
- 자식 클래스 선언을 같은 패키지 내로 제한한다.
- 추상클래스이므로 직접 객체 인스턴스 생성이 불가하다.
- `open class` 는 모든 곳에서 상속이 가능하다

##### 예시 코드
```kotlin
sealed class List<A> {
    abstract fun isEmpty(): Boolean
 
    internal object Nil: List<Nothing>() {
        override fun isEmpty(): Boolean = true
        override fun toString(): String = "[NIL]"
    }
 
    internal class Cons<A>(
        internal val head: A,
        internal val tail: List<A>
    ): List<A>() {
        override fun isEmpty(): Boolean = false
        override fun toString(): String = "[${toString("", this)}NIL]"
        private tailrec fun toString(acc: String, list: List<A>): String {
        // sealed class가 아니면 else를 사용하지 않아서 컴파일 에러 발생한다
            return when (list) {
                is Nil -> acc
                is Cons -> toString("$acc${list.head}, ", list.tail)
            }
        }
    }
}
```


##### 사용하는 이유

- 계층 구조 제한
    - `sealed class` 를 사용하면 특정 클래스 계층 구조 내에서만 하위 클래스를 정의할 수 있다
    - 이로써 클래스 계층 구조를 엄격하게 제한하고, 상속 계층 구조의 안전성을 보장할 수 있다
    - 새로운 하위 클래스가 추가되더라도, 그 클래스가 모든 경우에 대해 처리되지 않았다면 컴파일러가 경고를 표시한다
- 패턴 매칭
    - 패턴 매칭을 통해 모든 하위 클래스에 대한 처리를 명확하게 정의할 수 있다


## Nothing 
#### [참고] [Unit과 Nothing의 비교](https://medium.com/@lunay0ung/kotlin-unit%EA%B3%BC-nothing-e3ff9143fd65)

- 실행 흐름이 도달할 수 없는 구역을 나타내기 위한 타입이다.
- 어떠한 값도 포함하지 않는 타입으로, 생성자가 `private`으로 정의되어 있어 인스턴스를 생성할 수 없다.
- `Nothing`은 `Any`와 반대로, 모든 타입의 서브 타입이다.
  - 어떤것도 `Nothing`이 될 수 있지만, `Nothing`은 어떤것도 될 수 없다
- `throw` 표현식이 `Nothing` 타입을 갖는다

#### 사용 예
- 무한루프와 같이 함수가 리턴 될 일이 없는 경우 사용한다. (`Unit`은 함수는 종료되나, 리턴되는 값이 없는 경우 사용한다.)
- 예외를 던지는 함수의 경우 리턴타입으로 사용한다.
- 함수의 리턴 타입이 `Nothing?` 일 경우, 종료되지 않는 함수, 예외를 던지는 함수, `null`를 리턴하는 함수 세 가지 중 하나의 케이스가 가능하다.

## UnsafeVariance
- `@UnsafeVariance`는 변성 충돌에 대한 오류를 억제한다.
- 예시로 `List<out A>`로 정의된 클래스 내에서 `in`에 해당하는 위치에 제네릭 변수가 들어오는 경우 컴파일러는 이를 사용하지 못하도록 막는다 (에러 발생)
- 하지만 사용자가 `in`위치에 들어오는 A타입을 별도의 연산없이 또는 연산이 있더라도 안전하게 변환이 가능하다고 판단하는 경우 `@UnsafeVariance` 를 사용해서 `in`자리에 제네릭 변수를 사용할 수 있도록 해준다.
- 그러나 잘못되면 사용자의 책임이다.

```kotlin
// 위 코드에서 Nil의 경우 a: Nothing으로 들어오지만 연산이 바로 List<Nothing> -> List<A>로 변환되기 때문에 이슈가 없다고 판단되면 아래와 같이 어노테이션을 붙여서 컴파일 오류를 막을 수 있다
sealed class List<out A> {
    internal fun cons(a: @UnsafeVariance A) = Cons(a, this)
}
```

## Invoke
#### 이름 없이 호출할 수 있는 함수(연산자)

- `invoke`와 같이 이름을 부여한 함수임에도 불구하고 실행을 간편하게 할 수 있게 하는 것들을 연산자라고 부름
- `invoke`, `plus` 등

```kotlin
object MyFunction {
    operator fun invoke(str: String): String {
        return str.toUpperCase() // 모두 대문자로 바꿔줌
    }
}

//아래와 같이 이름 없이 호출할 수 있음
MyFunction("hello") // HELLO
```

-> 람다는 `invoke` 함수를 가진 익명의 객체이다

```kotlin
//람다 객체
val toUpperCase = { str: String -> str.toUpperCase() }

//아래와 같이 컴파일 됨
val toUpperCase = object : Function1<String, String> {
    override fun invoke(p1: String): String {
        return p1.toUpperCase()
    }
}
```
